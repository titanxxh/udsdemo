// Code generated by protoc-gen-go. DO NOT EDIT.
// source: subpub.proto

package subpub

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Header struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Generation           int32    `protobuf:"varint,2,opt,name=generation,proto3" json:"generation,omitempty"`
	From                 int32    `protobuf:"varint,3,opt,name=from,proto3" json:"from,omitempty"`
	To                   int32    `protobuf:"varint,4,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_299edc39f83d5d40, []int{0}
}

func (m *Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Header.Unmarshal(m, b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Header.Marshal(b, m, deterministic)
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return xxx_messageInfo_Header.Size(m)
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Header) GetGeneration() int32 {
	if m != nil {
		return m.Generation
	}
	return 0
}

func (m *Header) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Header) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

type UniMessage struct {
	Header               *Header  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	PayloadType          int32    `protobuf:"varint,2,opt,name=payload_type,json=payloadType,proto3" json:"payload_type,omitempty"`
	Payload              []byte   `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UniMessage) Reset()         { *m = UniMessage{} }
func (m *UniMessage) String() string { return proto.CompactTextString(m) }
func (*UniMessage) ProtoMessage()    {}
func (*UniMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_299edc39f83d5d40, []int{1}
}

func (m *UniMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UniMessage.Unmarshal(m, b)
}
func (m *UniMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UniMessage.Marshal(b, m, deterministic)
}
func (m *UniMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniMessage.Merge(m, src)
}
func (m *UniMessage) XXX_Size() int {
	return xxx_messageInfo_UniMessage.Size(m)
}
func (m *UniMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UniMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UniMessage proto.InternalMessageInfo

func (m *UniMessage) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *UniMessage) GetPayloadType() int32 {
	if m != nil {
		return m.PayloadType
	}
	return 0
}

func (m *UniMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ClientMessage struct {
	Header               *Header  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	PayloadType          int32    `protobuf:"varint,2,opt,name=payload_type,json=payloadType,proto3" json:"payload_type,omitempty"`
	Payload              []byte   `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientMessage) Reset()         { *m = ClientMessage{} }
func (m *ClientMessage) String() string { return proto.CompactTextString(m) }
func (*ClientMessage) ProtoMessage()    {}
func (*ClientMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_299edc39f83d5d40, []int{2}
}

func (m *ClientMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientMessage.Unmarshal(m, b)
}
func (m *ClientMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientMessage.Marshal(b, m, deterministic)
}
func (m *ClientMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientMessage.Merge(m, src)
}
func (m *ClientMessage) XXX_Size() int {
	return xxx_messageInfo_ClientMessage.Size(m)
}
func (m *ClientMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ClientMessage proto.InternalMessageInfo

func (m *ClientMessage) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ClientMessage) GetPayloadType() int32 {
	if m != nil {
		return m.PayloadType
	}
	return 0
}

func (m *ClientMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ServerMessage struct {
	Header               *Header  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	PayloadType          int32    `protobuf:"varint,2,opt,name=payload_type,json=payloadType,proto3" json:"payload_type,omitempty"`
	Payload              []byte   `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerMessage) Reset()         { *m = ServerMessage{} }
func (m *ServerMessage) String() string { return proto.CompactTextString(m) }
func (*ServerMessage) ProtoMessage()    {}
func (*ServerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_299edc39f83d5d40, []int{3}
}

func (m *ServerMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerMessage.Unmarshal(m, b)
}
func (m *ServerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerMessage.Marshal(b, m, deterministic)
}
func (m *ServerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerMessage.Merge(m, src)
}
func (m *ServerMessage) XXX_Size() int {
	return xxx_messageInfo_ServerMessage.Size(m)
}
func (m *ServerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ServerMessage proto.InternalMessageInfo

func (m *ServerMessage) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ServerMessage) GetPayloadType() int32 {
	if m != nil {
		return m.PayloadType
	}
	return 0
}

func (m *ServerMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterType((*Header)(nil), "subpub.Header")
	proto.RegisterType((*UniMessage)(nil), "subpub.UniMessage")
	proto.RegisterType((*ClientMessage)(nil), "subpub.ClientMessage")
	proto.RegisterType((*ServerMessage)(nil), "subpub.ServerMessage")
}

func init() { proto.RegisterFile("subpub.proto", fileDescriptor_299edc39f83d5d40) }

var fileDescriptor_299edc39f83d5d40 = []byte{
	// 281 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x92, 0xc1, 0x4b, 0xf3, 0x40,
	0x14, 0xc4, 0xbf, 0xcd, 0x97, 0xae, 0xf8, 0x5a, 0x7b, 0x78, 0x20, 0x04, 0x0f, 0x52, 0x73, 0x90,
	0x9e, 0x4a, 0xa9, 0x17, 0xf5, 0x26, 0x3d, 0xe8, 0x45, 0x94, 0x54, 0xf1, 0x22, 0xc8, 0xd6, 0x3c,
	0x93, 0x85, 0x74, 0x37, 0x6e, 0x5e, 0x84, 0xfc, 0xe7, 0x1e, 0xa5, 0xdb, 0x54, 0xec, 0x31, 0x97,
	0xde, 0x76, 0x66, 0x98, 0xfd, 0x0d, 0xcb, 0xc2, 0xa0, 0xaa, 0x97, 0x65, 0xbd, 0x9c, 0x94, 0xce,
	0xb2, 0x45, 0xb9, 0x51, 0xf1, 0x2b, 0xc8, 0x3b, 0x52, 0x29, 0x39, 0x1c, 0x42, 0xa0, 0xd3, 0x48,
	0x8c, 0xc4, 0x38, 0x4c, 0x02, 0x9d, 0xe2, 0x29, 0x40, 0x46, 0x86, 0x9c, 0x62, 0x6d, 0x4d, 0x14,
	0x8c, 0xc4, 0xb8, 0x97, 0xfc, 0x71, 0x10, 0x21, 0xfc, 0x70, 0x76, 0x15, 0xfd, 0xf7, 0x89, 0x3f,
	0xaf, 0xef, 0x60, 0x1b, 0x85, 0xde, 0x09, 0xd8, 0xc6, 0x9f, 0x00, 0xcf, 0x46, 0xdf, 0x53, 0x55,
	0xa9, 0x8c, 0xf0, 0x1c, 0x64, 0xee, 0x59, 0x9e, 0xd2, 0x9f, 0x0d, 0x27, 0xed, 0xa4, 0xcd, 0x82,
	0xa4, 0x4d, 0xf1, 0x0c, 0x06, 0xa5, 0x6a, 0x0a, 0xab, 0xd2, 0x37, 0x6e, 0x4a, 0x6a, 0xd9, 0xfd,
	0xd6, 0x7b, 0x6a, 0x4a, 0xc2, 0x08, 0x0e, 0x5a, 0xe9, 0xf9, 0x83, 0x64, 0x2b, 0x63, 0x86, 0xa3,
	0x79, 0xa1, 0xc9, 0xf0, 0xbe, 0xa9, 0x0b, 0x72, 0x5f, 0xe4, 0xf6, 0x49, 0x9d, 0x7d, 0x0b, 0x38,
	0x5c, 0xb0, 0x23, 0xb5, 0xd2, 0x26, 0xc3, 0x4b, 0x90, 0xb7, 0xc4, 0x0f, 0x86, 0xf0, 0x78, 0x0b,
	0xdb, 0x79, 0x89, 0x93, 0x5f, 0x7b, 0x67, 0x6a, 0xfc, 0x0f, 0xaf, 0xa0, 0xf7, 0xa2, 0xf8, 0x3d,
	0xef, 0x5a, 0x9c, 0x0a, 0xbc, 0x06, 0xf9, 0x58, 0xf3, 0x4d, 0x51, 0x74, 0xed, 0x8e, 0xd7, 0xdd,
	0x70, 0x9e, 0x2b, 0xee, 0xde, 0x9c, 0x8a, 0xa5, 0xf4, 0xdf, 0xf8, 0xe2, 0x27, 0x00, 0x00, 0xff,
	0xff, 0xda, 0xf1, 0xc4, 0xca, 0xd6, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamingClient is the client API for Streaming service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingClient interface {
	// A simple RPC.
	GetOne(ctx context.Context, in *ClientMessage, opts ...grpc.CallOption) (*ServerMessage, error)
	// A server-to-client streaming RPC.
	Watch(ctx context.Context, in *ClientMessage, opts ...grpc.CallOption) (Streaming_WatchClient, error)
	// A client-to-server streaming RPC.
	PutAll(ctx context.Context, opts ...grpc.CallOption) (Streaming_PutAllClient, error)
	// A Bidirectional streaming RPC.
	Chat(ctx context.Context, opts ...grpc.CallOption) (Streaming_ChatClient, error)
}

type streamingClient struct {
	cc *grpc.ClientConn
}

func NewStreamingClient(cc *grpc.ClientConn) StreamingClient {
	return &streamingClient{cc}
}

func (c *streamingClient) GetOne(ctx context.Context, in *ClientMessage, opts ...grpc.CallOption) (*ServerMessage, error) {
	out := new(ServerMessage)
	err := c.cc.Invoke(ctx, "/subpub.Streaming/GetOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamingClient) Watch(ctx context.Context, in *ClientMessage, opts ...grpc.CallOption) (Streaming_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streaming_serviceDesc.Streams[0], "/subpub.Streaming/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streaming_WatchClient interface {
	Recv() (*ServerMessage, error)
	grpc.ClientStream
}

type streamingWatchClient struct {
	grpc.ClientStream
}

func (x *streamingWatchClient) Recv() (*ServerMessage, error) {
	m := new(ServerMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) PutAll(ctx context.Context, opts ...grpc.CallOption) (Streaming_PutAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streaming_serviceDesc.Streams[1], "/subpub.Streaming/PutAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingPutAllClient{stream}
	return x, nil
}

type Streaming_PutAllClient interface {
	Send(*ClientMessage) error
	CloseAndRecv() (*ServerMessage, error)
	grpc.ClientStream
}

type streamingPutAllClient struct {
	grpc.ClientStream
}

func (x *streamingPutAllClient) Send(m *ClientMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingPutAllClient) CloseAndRecv() (*ServerMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ServerMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) Chat(ctx context.Context, opts ...grpc.CallOption) (Streaming_ChatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streaming_serviceDesc.Streams[2], "/subpub.Streaming/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingChatClient{stream}
	return x, nil
}

type Streaming_ChatClient interface {
	Send(*ClientMessage) error
	Recv() (*ServerMessage, error)
	grpc.ClientStream
}

type streamingChatClient struct {
	grpc.ClientStream
}

func (x *streamingChatClient) Send(m *ClientMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingChatClient) Recv() (*ServerMessage, error) {
	m := new(ServerMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingServer is the server API for Streaming service.
type StreamingServer interface {
	// A simple RPC.
	GetOne(context.Context, *ClientMessage) (*ServerMessage, error)
	// A server-to-client streaming RPC.
	Watch(*ClientMessage, Streaming_WatchServer) error
	// A client-to-server streaming RPC.
	PutAll(Streaming_PutAllServer) error
	// A Bidirectional streaming RPC.
	Chat(Streaming_ChatServer) error
}

// UnimplementedStreamingServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingServer struct {
}

func (*UnimplementedStreamingServer) GetOne(ctx context.Context, req *ClientMessage) (*ServerMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOne not implemented")
}
func (*UnimplementedStreamingServer) Watch(req *ClientMessage, srv Streaming_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (*UnimplementedStreamingServer) PutAll(srv Streaming_PutAllServer) error {
	return status.Errorf(codes.Unimplemented, "method PutAll not implemented")
}
func (*UnimplementedStreamingServer) Chat(srv Streaming_ChatServer) error {
	return status.Errorf(codes.Unimplemented, "method Chat not implemented")
}

func RegisterStreamingServer(s *grpc.Server, srv StreamingServer) {
	s.RegisterService(&_Streaming_serviceDesc, srv)
}

func _Streaming_GetOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamingServer).GetOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/subpub.Streaming/GetOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamingServer).GetOne(ctx, req.(*ClientMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streaming_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClientMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingServer).Watch(m, &streamingWatchServer{stream})
}

type Streaming_WatchServer interface {
	Send(*ServerMessage) error
	grpc.ServerStream
}

type streamingWatchServer struct {
	grpc.ServerStream
}

func (x *streamingWatchServer) Send(m *ServerMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Streaming_PutAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamingServer).PutAll(&streamingPutAllServer{stream})
}

type Streaming_PutAllServer interface {
	SendAndClose(*ServerMessage) error
	Recv() (*ClientMessage, error)
	grpc.ServerStream
}

type streamingPutAllServer struct {
	grpc.ServerStream
}

func (x *streamingPutAllServer) SendAndClose(m *ServerMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamingPutAllServer) Recv() (*ClientMessage, error) {
	m := new(ClientMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Streaming_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamingServer).Chat(&streamingChatServer{stream})
}

type Streaming_ChatServer interface {
	Send(*ServerMessage) error
	Recv() (*ClientMessage, error)
	grpc.ServerStream
}

type streamingChatServer struct {
	grpc.ServerStream
}

func (x *streamingChatServer) Send(m *ServerMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamingChatServer) Recv() (*ClientMessage, error) {
	m := new(ClientMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Streaming_serviceDesc = grpc.ServiceDesc{
	ServiceName: "subpub.Streaming",
	HandlerType: (*StreamingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOne",
			Handler:    _Streaming_GetOne_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Streaming_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutAll",
			Handler:       _Streaming_PutAll_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Chat",
			Handler:       _Streaming_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "subpub.proto",
}
